var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"ESCHighLevel","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"ESCHighLevel.h\"              /* Model's header file */\r\n\r\nstatic RT_MODEL rtM_;\r\nstatic RT_MODEL *const rtMPtr = &rtM_; /* Real-time model */\r\nstatic DW rtDW;                        /* Observable states */\r\n\r\n/* '<Root>/whlspd' */\r\nstatic real_T rtU_whlspd[4];\r\n\r\n/* '<Root>/acc_x' */\r\nstatic real_T rtU_acc_x;\r\n\r\n/* '<Root>/cur_mc_pressure' */\r\nstatic real_T rtU_cur_mc_pressure;\r\n\r\n/* '<Root>/cur_wc_pressure' */\r\nstatic real_T rtU_cur_wc_pressure[4];\r\n\r\n/* '<Root>/abs_para' */\r\nstatic real32_T rtU_abs_para[8];\r\n\r\n/* '<Root>/abs_use_external_para' */\r\nstatic int32_T rtU_abs_use_external_para;\r\n\r\n/* '<Root>/steer_wheel_angle' */\r\nstatic real_T rtU_steering_wheel_angle_origin;\r\n\r\n/* '<Root>/est_veh_spd' */\r\nstatic real_T rtY_est_veh_spd;\r\n\r\n/* '<Root>/des_wc_pressure' */\r\nstatic int32_T rtY_des_wc_pressure[4];\r\n\r\n/* '<Root>/abs_valve_state' */\r\nstatic int32_T rtY_abs_valve_state[4];\r\n\r\n/* '<Root>/valve_control_mode' */\r\nstatic int32_T rtY_valve_control_mode[4];\r\n\r\n/* '<Root>/slip_rate' */\r\nstatic real_T rtY_slip_rate[4];\r\n\r\n/* '<Root>/delta_slip_rate' */\r\nstatic real_T rtY_delta_slip_rate[4];\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(RT_MODEL *const rtM);\r\nvoid rt_OneStep(RT_MODEL *const rtM)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  ESCHighLevel_step(rtM, rtU_whlspd, rtU_acc_x, rtU_cur_mc_pressure,\r\n                    rtU_cur_wc_pressure, rtU_abs_para, rtU_abs_use_external_para,\r\n                    &rtY_est_veh_spd, rtY_abs_valve_state, rtY_slip_rate,\r\n                    rtY_delta_slip_rate);\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  RT_MODEL *const rtM = rtMPtr;\r\n\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Pack model data into RTM */\r\n  rtM->dwork = &rtDW;\r\n\r\n  /* Initialize model */\r\n  ESCHighLevel_initialize(rtM);\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.008 seconds (the model's base sample time) here.  The\r\n   * call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep(rtM);\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ESCHighLevel.c","type":"source","group":"model","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ESCHighLevel.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ESCHighLevel.h\"\r\n#include \"ESCHighLevel_private.h\"\r\n\r\n/* Named constants for Chart: '<S8>/State Machine' */\r\n#define IN_Keep_Pressure               ((uint8_T)1U)\r\n#define IN_Reduce_Pressure             ((uint8_T)2U)\r\n#define IN_Set_Pressure                ((uint8_T)3U)\r\n\r\n/*\r\n * System initialize for atomic system:\r\n *    '<S1>/SingleWheelStateMachine'\r\n *    '<S1>/SingleWheelStateMachine1'\r\n *    '<S1>/SingleWheelStateMachine2'\r\n *    '<S1>/SingleWheelStateMachine3'\r\n */\r\nvoid SingleWheelStateMachine_Init(real_T *rty_wc_p_des, int32_T *rty_abs_state)\r\n{\r\n  /* SystemInitialize for Chart: '<S8>/State Machine' */\r\n  *rty_wc_p_des = 0.0;\r\n  *rty_abs_state = 0;\r\n}\r\n\r\n/*\r\n * Output and update for atomic system:\r\n *    '<S1>/SingleWheelStateMachine'\r\n *    '<S1>/SingleWheelStateMachine1'\r\n *    '<S1>/SingleWheelStateMachine2'\r\n *    '<S1>/SingleWheelStateMachine3'\r\n */\r\nvoid SingleWheelStateMachine(real_T rtu_set_p, real_T rtu_wc_p_cur, real_T rtu_u,\r\n  real_T rtu_slip_rate, const real32_T rtu_abs_para[5], int32_T\r\n  rtu_external_para, real_T *rty_wc_p_des, int32_T *rty_abs_state,\r\n  DW_SingleWheelStateMachine *localDW)\r\n{\r\n  real_T k;\r\n  real_T rtb_Switch_d5_idx_0;\r\n  real_T rtb_Switch_d5_idx_1;\r\n  real_T rtb_Switch_d5_idx_2;\r\n  real_T rtb_Switch_d5_idx_4;\r\n\r\n  /* Switch: '<S8>/Switch' incorporates:\r\n   *  Constant: '<S8>/Constant'\r\n   *  Constant: '<S8>/Constant1'\r\n   *  Constant: '<S8>/Constant2'\r\n   */\r\n  if (rtu_external_para > 0) {\r\n    rtb_Switch_d5_idx_0 = rtu_abs_para[0];\r\n    rtb_Switch_d5_idx_1 = rtu_abs_para[1];\r\n    rtb_Switch_d5_idx_2 = rtu_abs_para[2];\r\n\r\n    /* MATLAB Function: '<S8>/CalLockCriterion' */\r\n    k = rtu_abs_para[3];\r\n    rtb_Switch_d5_idx_4 = rtu_abs_para[4];\r\n  } else {\r\n    rtb_Switch_d5_idx_0 = 0.05;\r\n    rtb_Switch_d5_idx_1 = 0.05;\r\n    rtb_Switch_d5_idx_2 = 0.15;\r\n\r\n    /* MATLAB Function: '<S8>/CalLockCriterion' incorporates:\r\n     *  Constant: '<S8>/Constant'\r\n     *  Constant: '<S8>/Constant1'\r\n     *  Constant: '<S8>/Constant2'\r\n     */\r\n    k = 0.006;\r\n    rtb_Switch_d5_idx_4 = 0.006;\r\n  }\r\n\r\n  /* End of Switch: '<S8>/Switch' */\r\n\r\n  /* MATLAB Function: '<S8>/CalLockCriterion' incorporates:\r\n   *  Delay: '<S8>/Delay'\r\n   *  Delay: '<S8>/Delay1'\r\n   */\r\n  if (localDW->Delay1_DSTATE == 2) {\r\n    k = rtb_Switch_d5_idx_4;\r\n  }\r\n\r\n  k = (rtu_slip_rate - localDW->Delay_DSTATE[0]) - k;\r\n\r\n  /* Chart: '<S8>/State Machine' incorporates:\r\n   *  Constant: '<S13>/Constant'\r\n   *  RelationalOperator: '<S13>/Compare'\r\n   */\r\n  if (localDW->is_active_c20_ESCHighLevel == 0U) {\r\n    localDW->is_active_c20_ESCHighLevel = 1U;\r\n    localDW->is_c20_ESCHighLevel = IN_Set_Pressure;\r\n    *rty_abs_state = 1;\r\n    *rty_wc_p_des = rtu_set_p;\r\n  } else {\r\n    switch (localDW->is_c20_ESCHighLevel) {\r\n     case IN_Keep_Pressure:\r\n      if ((rtu_slip_rate >= rtb_Switch_d5_idx_2) && (k >= 0.0)) {\r\n        localDW->is_c20_ESCHighLevel = IN_Reduce_Pressure;\r\n        *rty_abs_state = 3;\r\n        *rty_wc_p_des = 0.0;\r\n      } else if (rtu_slip_rate < rtb_Switch_d5_idx_0) {\r\n        localDW->is_c20_ESCHighLevel = IN_Set_Pressure;\r\n        *rty_abs_state = 1;\r\n        *rty_wc_p_des = rtu_set_p;\r\n      } else {\r\n        *rty_abs_state = 2;\r\n        *rty_wc_p_des = rtu_wc_p_cur;\r\n      }\r\n      break;\r\n\r\n     case IN_Reduce_Pressure:\r\n      if (rtu_slip_rate < rtb_Switch_d5_idx_0) {\r\n        localDW->is_c20_ESCHighLevel = IN_Set_Pressure;\r\n        *rty_abs_state = 1;\r\n        *rty_wc_p_des = rtu_set_p;\r\n      } else {\r\n        *rty_abs_state = 3;\r\n        *rty_wc_p_des = 0.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Set_Pressure: */\r\n      if ((rtu_slip_rate >= rtb_Switch_d5_idx_1) && (rtu_u >= 2.7777777777777777)\r\n          && (k >= 0.0)) {\r\n        localDW->is_c20_ESCHighLevel = IN_Keep_Pressure;\r\n        *rty_abs_state = 2;\r\n        *rty_wc_p_des = rtu_wc_p_cur;\r\n      } else {\r\n        *rty_abs_state = 1;\r\n        *rty_wc_p_des = rtu_set_p;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S8>/State Machine' */\r\n\r\n  /* Update for Delay: '<S8>/Delay1' */\r\n  localDW->Delay1_DSTATE = *rty_abs_state;\r\n\r\n  /* Update for Delay: '<S8>/Delay' */\r\n  localDW->Delay_DSTATE[0] = localDW->Delay_DSTATE[1];\r\n  localDW->Delay_DSTATE[1] = localDW->Delay_DSTATE[2];\r\n  localDW->Delay_DSTATE[2] = localDW->Delay_DSTATE[3];\r\n  localDW->Delay_DSTATE[3] = rtu_slip_rate;\r\n}\r\n\r\n/* System initialize for atomic system: */\r\nvoid MovingAverage1_Init(DW_MovingAverage1 *localDW)\r\n{\r\n  g_dsp_internal_SlidingWindowAve *iobj_0;\r\n\r\n  /* Start for MATLABSystem: '<Root>/Moving Average1' */\r\n  localDW->obj.matlabCodegenIsDeleted = true;\r\n  localDW->obj.isInitialized = 0;\r\n  localDW->obj.NumChannels = -1;\r\n  localDW->obj.matlabCodegenIsDeleted = false;\r\n  localDW->objisempty = true;\r\n  localDW->obj.isSetupComplete = false;\r\n  localDW->obj.isInitialized = 1;\r\n  localDW->obj.NumChannels = 1;\r\n  localDW->obj._pobj0.isInitialized = 0;\r\n  localDW->obj._pobj0.isInitialized = 0;\r\n  localDW->obj.pStatistic = &localDW->obj._pobj0;\r\n  localDW->obj.isSetupComplete = true;\r\n  localDW->obj.TunablePropsChanged = false;\r\n\r\n  /* InitializeConditions for MATLABSystem: '<Root>/Moving Average1' */\r\n  iobj_0 = localDW->obj.pStatistic;\r\n  if (iobj_0->isInitialized == 1) {\r\n    iobj_0->pCumSum = 0.0;\r\n    iobj_0->pCumSumRev[0] = 0.0;\r\n    iobj_0->pCumSumRev[1] = 0.0;\r\n    iobj_0->pCumRevIndex = 1.0;\r\n    iobj_0->pModValueRev = 0.0;\r\n  }\r\n\r\n  /* End of InitializeConditions for MATLABSystem: '<Root>/Moving Average1' */\r\n}\r\n\r\n/* Output and update for atomic system: */\r\nvoid MovingAverage1(real_T rtu_0, DW_MovingAverage1 *localDW)\r\n{\r\n  g_dsp_internal_SlidingWindowAve *obj;\r\n  real_T csumrev[2];\r\n  real_T csum;\r\n  real_T cumRevIndex;\r\n  real_T modValueRev;\r\n  real_T z;\r\n\r\n  /* MATLABSystem: '<Root>/Moving Average1' */\r\n  if (localDW->obj.TunablePropsChanged) {\r\n    localDW->obj.TunablePropsChanged = false;\r\n  }\r\n\r\n  obj = localDW->obj.pStatistic;\r\n  if (obj->isInitialized != 1) {\r\n    obj->isSetupComplete = false;\r\n    obj->isInitialized = 1;\r\n    obj->pCumSum = 0.0;\r\n    obj->pCumSumRev[0] = 0.0;\r\n    obj->pCumSumRev[1] = 0.0;\r\n    obj->pCumRevIndex = 1.0;\r\n    obj->pModValueRev = 0.0;\r\n    obj->isSetupComplete = true;\r\n    obj->pCumSum = 0.0;\r\n    obj->pCumSumRev[0] = 0.0;\r\n    obj->pCumSumRev[1] = 0.0;\r\n    obj->pCumRevIndex = 1.0;\r\n    obj->pModValueRev = 0.0;\r\n  }\r\n\r\n  cumRevIndex = obj->pCumRevIndex;\r\n  csum = obj->pCumSum;\r\n  csumrev[0] = obj->pCumSumRev[0];\r\n  csumrev[1] = obj->pCumSumRev[1];\r\n  modValueRev = obj->pModValueRev;\r\n  z = 0.0;\r\n\r\n  /* MATLABSystem: '<Root>/Moving Average1' */\r\n  localDW->MovingAverage1_p = 0.0;\r\n\r\n  /* MATLABSystem: '<Root>/Moving Average1' */\r\n  csum += rtu_0;\r\n  if (modValueRev == 0.0) {\r\n    z = csumrev[(int32_T)cumRevIndex - 1] + csum;\r\n  }\r\n\r\n  csumrev[(int32_T)cumRevIndex - 1] = rtu_0;\r\n  if (cumRevIndex != 2.0) {\r\n    cumRevIndex = 2.0;\r\n  } else {\r\n    cumRevIndex = 1.0;\r\n    csum = 0.0;\r\n    csumrev[0] += csumrev[1];\r\n  }\r\n\r\n  if (modValueRev == 0.0) {\r\n    /* MATLABSystem: '<Root>/Moving Average1' */\r\n    localDW->MovingAverage1_p = z / 3.0;\r\n  }\r\n\r\n  obj->pCumSum = csum;\r\n  obj->pCumSumRev[0] = csumrev[0];\r\n  obj->pCumSumRev[1] = csumrev[1];\r\n  obj->pCumRevIndex = cumRevIndex;\r\n  if (modValueRev > 0.0) {\r\n    obj->pModValueRev = modValueRev - 1.0;\r\n  } else {\r\n    obj->pModValueRev = 0.0;\r\n  }\r\n}\r\n\r\n/* Model step function */\r\nvoid ESCHighLevel_step(RT_MODEL *const rtM, real_T rtU_whlspd[4], real_T\r\n  rtU_acc_x, real_T rtU_cur_mc_pressure, real_T rtU_cur_wc_pressure[4], real32_T\r\n  rtU_abs_para[8], int32_T rtU_abs_use_external_para, real_T *rtY_est_veh_spd,\r\n  int32_T rtY_abs_valve_state[4], real_T rtY_slip_rate[4], real_T\r\n  rtY_delta_slip_rate[4])\r\n{\r\n  DW *rtDW = rtM->dwork;\r\n\r\n  /* local block i/o variables */\r\n  real_T rtb_Switch_o[4];\r\n  real_T rtb_Gain5[4];\r\n  real_T rtb_TmpSignalConversionAtSlipRa[4];\r\n  real_T rtb_Switch1;\r\n  real_T rtb_mc_pressure;\r\n  int32_T rtb_abs_state;\r\n  int32_T rtb_abs_state_e;\r\n  int32_T rtb_abs_state_n;\r\n  int32_T rtb_out_state;\r\n  boolean_T rtb_RelationalOperator;\r\n  boolean_T rtb_abs_is_on;\r\n\r\n  /* Gain: '<Root>/Gain5' incorporates:\r\n   *  Inport: '<Root>/whlspd'\r\n   */\r\n  rtb_Gain5[0] = 0.376 * rtU_whlspd[0];\r\n  rtb_Gain5[1] = 0.376 * rtU_whlspd[1];\r\n  rtb_Gain5[2] = 0.376 * rtU_whlspd[2];\r\n  rtb_Gain5[3] = 0.376 * rtU_whlspd[3];\r\n\r\n  /* SignalConversion generated from: '<Root>/SlipRateCalFunc' */\r\n  rtb_TmpSignalConversionAtSlipRa[0] = rtb_Gain5[3];\r\n  rtb_TmpSignalConversionAtSlipRa[1] = rtb_Gain5[0];\r\n  rtb_TmpSignalConversionAtSlipRa[2] = rtb_Gain5[1];\r\n  rtb_TmpSignalConversionAtSlipRa[3] = rtb_Gain5[2];\r\n\r\n  /* Saturate: '<Root>/Saturation' incorporates:\r\n   *  Inport: '<Root>/cur_mc_pressure'\r\n   */\r\n  if (rtU_cur_mc_pressure > 10.0) {\r\n    rtb_mc_pressure = 10.0;\r\n  } else if (rtU_cur_mc_pressure < -0.5) {\r\n    rtb_mc_pressure = -0.5;\r\n  } else {\r\n    rtb_mc_pressure = rtU_cur_mc_pressure;\r\n  }\r\n\r\n  /* End of Saturate: '<Root>/Saturation' */\r\n\r\n  /* Switch: '<Root>/Switch2' incorporates:\r\n   *  Constant: '<Root>/Constant6'\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   */\r\n  if (rtU_abs_use_external_para > 0) {\r\n    rtb_Switch1 = rtU_abs_para[7];\r\n  } else {\r\n    rtb_Switch1 = 0.8;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch2' */\r\n\r\n  /* RelationalOperator: '<Root>/Relational Operator' */\r\n  rtb_RelationalOperator = (rtb_mc_pressure > rtb_Switch1);\r\n\r\n  /* Delay: '<Root>/Delay' */\r\n  rtb_abs_is_on = rtDW->Delay_DSTATE;\r\n\r\n  /* Switch: '<Root>/Switch1' incorporates:\r\n   *  Constant: '<Root>/Constant7'\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   */\r\n  if (rtU_abs_use_external_para > 0) {\r\n    rtb_Switch1 = rtU_abs_para[5];\r\n  } else {\r\n    rtb_Switch1 = 40.0;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch1' */\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\r\n   *  Delay: '<Root>/Delay'\r\n   *  Delay: '<Root>/Delay2'\r\n   */\r\n  if (rtDW->Delay_DSTATE) {\r\n    rtb_out_state = 1;\r\n    if ((rtDW->counter < rtb_Switch1) && (rtDW->counter > 0.0)) {\r\n      rtDW->counter++;\r\n    } else {\r\n      rtDW->counter = 0.0;\r\n    }\r\n  } else if (!rtDW->Delay2_DSTATE) {\r\n    if ((rtDW->counter < rtb_Switch1) && (rtDW->counter > 0.0)) {\r\n      rtb_out_state = 1;\r\n      rtDW->counter++;\r\n    } else {\r\n      rtDW->counter = 0.0;\r\n      rtb_out_state = 0;\r\n    }\r\n  } else {\r\n    rtDW->counter = 1.0;\r\n    rtb_out_state = 1;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/VehSpdEstFunc' */\r\n  /* Outport: '<Root>/est_veh_spd' incorporates:\r\n   *  DataTypeConversion: '<Root>/Cast To Boolean'\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   *  Inport: '<Root>/acc_x'\r\n   */\r\n  *rtY_est_veh_spd = VehSpdEstFunction(rtb_Gain5[3], rtb_Gain5[0], rtb_Gain5[1],\r\n    rtb_Gain5[2], rtb_RelationalOperator, rtU_acc_x, rtb_out_state != 0,\r\n    rtU_abs_use_external_para, rtU_abs_para[6], &rtDW->VehSpdEstFunc);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/VehSpdEstFunc' */\r\n\r\n  /* Switch: '<S7>/Switch' incorporates:\r\n   *  Outport: '<Root>/est_veh_spd'\r\n   */\r\n  rtb_Gain5[0] = *rtY_est_veh_spd;\r\n  rtb_Gain5[1] = *rtY_est_veh_spd;\r\n  rtb_Gain5[2] = *rtY_est_veh_spd;\r\n  rtb_Gain5[3] = *rtY_est_veh_spd;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/SlipRateCalFunc' */\r\n  SlipRateCalFunc(rtb_TmpSignalConversionAtSlipRa, rtb_Gain5, rtb_Switch_o);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/SlipRateCalFunc' */\r\n  MovingAverage1(rtb_Switch_o[1], &rtDW->MovingAverage2);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/SingleWheelStateMachine1' */\r\n  /* Inport: '<Root>/cur_wc_pressure' incorporates:\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   *  Outport: '<Root>/est_veh_spd'\r\n   */\r\n  SingleWheelStateMachine(rtb_mc_pressure, rtU_cur_wc_pressure[0],\r\n    *rtY_est_veh_spd, rtDW->MovingAverage2.MovingAverage1_p, &rtU_abs_para[0],\r\n    rtU_abs_use_external_para, &rtb_Switch1, &rtb_abs_state_e,\r\n    &rtDW->SingleWheelStateMachine1);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/SingleWheelStateMachine1' */\r\n  MovingAverage1(rtb_Switch_o[2], &rtDW->MovingAverage3);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/SingleWheelStateMachine2' */\r\n  /* Inport: '<Root>/cur_wc_pressure' incorporates:\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   *  Outport: '<Root>/est_veh_spd'\r\n   */\r\n  SingleWheelStateMachine(rtb_mc_pressure, rtU_cur_wc_pressure[1],\r\n    *rtY_est_veh_spd, rtDW->MovingAverage3.MovingAverage1_p, &rtU_abs_para[0],\r\n    rtU_abs_use_external_para, &rtb_Switch1, &rtb_abs_state_n,\r\n    &rtDW->SingleWheelStateMachine2);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/SingleWheelStateMachine2' */\r\n  MovingAverage1(rtb_Switch_o[3], &rtDW->MovingAverage4);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/SingleWheelStateMachine3' */\r\n  /* Inport: '<Root>/cur_wc_pressure' incorporates:\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   *  Outport: '<Root>/est_veh_spd'\r\n   */\r\n  SingleWheelStateMachine(rtb_mc_pressure, rtU_cur_wc_pressure[2],\r\n    *rtY_est_veh_spd, rtDW->MovingAverage4.MovingAverage1_p, &rtU_abs_para[0],\r\n    rtU_abs_use_external_para, &rtb_Switch1, &rtb_abs_state,\r\n    &rtDW->SingleWheelStateMachine3);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/SingleWheelStateMachine3' */\r\n  MovingAverage1(rtb_Switch_o[0], &rtDW->MovingAverage1_p);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/SingleWheelStateMachine' */\r\n  /* Inport: '<Root>/cur_wc_pressure' incorporates:\r\n   *  Inport: '<Root>/abs_para'\r\n   *  Inport: '<Root>/abs_use_external_para'\r\n   *  Outport: '<Root>/est_veh_spd'\r\n   */\r\n  SingleWheelStateMachine(rtb_mc_pressure, rtU_cur_wc_pressure[3],\r\n    *rtY_est_veh_spd, rtDW->MovingAverage1_p.MovingAverage1_p, &rtU_abs_para[0],\r\n    rtU_abs_use_external_para, &rtb_Switch1, &rtb_out_state,\r\n    &rtDW->SingleWheelStateMachine_d);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/SingleWheelStateMachine' */\r\n\r\n  /* Switch: '<Root>/Switch3' incorporates:\r\n   *  Constant: '<Root>/Constant8'\r\n   *  Constant: '<S1>/Constant12'\r\n   *  Gain: '<S1>/Gain'\r\n   *  Gain: '<S1>/Gain1'\r\n   *  Gain: '<S1>/Gain2'\r\n   *  Gain: '<S1>/Gain3'\r\n   *  Sum: '<S1>/Add'\r\n   *  Sum: '<S1>/Add1'\r\n   *  Sum: '<S1>/Add2'\r\n   *  Sum: '<S1>/Add3'\r\n   */\r\n  if (rtb_RelationalOperator) {\r\n    rtb_abs_state_e = 2 - rtb_abs_state_e;\r\n    rtb_abs_state_n = 2 - rtb_abs_state_n;\r\n    rtb_abs_state = 2 - rtb_abs_state;\r\n    rtb_out_state = 2 - rtb_out_state;\r\n  } else {\r\n    rtb_abs_state_e = 1;\r\n    rtb_abs_state_n = 1;\r\n    rtb_abs_state = 1;\r\n    rtb_out_state = 1;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch3' */\r\n\r\n  /* Outport: '<Root>/abs_valve_state' */\r\n  rtY_abs_valve_state[0] = rtb_abs_state_e;\r\n  rtY_abs_valve_state[1] = rtb_abs_state_n;\r\n  rtY_abs_valve_state[2] = rtb_abs_state;\r\n  rtY_abs_valve_state[3] = rtb_out_state;\r\n\r\n  /* MATLAB Function: '<Root>/CalMaxValveState1' */\r\n  rtb_mc_pressure = 0.0;\r\n\r\n  /* Outport: '<Root>/delta_slip_rate' incorporates:\r\n   *  Delay: '<Root>/Delay1'\r\n   *  SignalConversion generated from: '<Root>/Delay1'\r\n   *  Sum: '<Root>/Add1'\r\n   */\r\n  rtY_delta_slip_rate[0] = rtDW->MovingAverage1_p.MovingAverage1_p -\r\n    rtDW->Delay1_DSTATE[0];\r\n\r\n  /* MATLAB Function: '<Root>/CalMaxValveState1' */\r\n  if (rtb_abs_state_e < 0.5) {\r\n    rtb_mc_pressure = 1.0;\r\n  }\r\n\r\n  /* Outport: '<Root>/delta_slip_rate' incorporates:\r\n   *  Delay: '<Root>/Delay1'\r\n   *  SignalConversion generated from: '<Root>/Delay1'\r\n   *  Sum: '<Root>/Add1'\r\n   */\r\n  rtY_delta_slip_rate[1] = rtDW->MovingAverage2.MovingAverage1_p -\r\n    rtDW->Delay1_DSTATE[1];\r\n\r\n  /* MATLAB Function: '<Root>/CalMaxValveState1' */\r\n  if (rtb_abs_state_n < 0.5) {\r\n    rtb_mc_pressure = 1.0;\r\n  }\r\n\r\n  /* Outport: '<Root>/delta_slip_rate' incorporates:\r\n   *  Delay: '<Root>/Delay1'\r\n   *  SignalConversion generated from: '<Root>/Delay1'\r\n   *  Sum: '<Root>/Add1'\r\n   */\r\n  rtY_delta_slip_rate[2] = rtDW->MovingAverage3.MovingAverage1_p -\r\n    rtDW->Delay1_DSTATE[2];\r\n\r\n  /* MATLAB Function: '<Root>/CalMaxValveState1' */\r\n  if (rtb_abs_state < 0.5) {\r\n    rtb_mc_pressure = 1.0;\r\n  }\r\n\r\n  /* Outport: '<Root>/delta_slip_rate' incorporates:\r\n   *  Delay: '<Root>/Delay1'\r\n   *  SignalConversion generated from: '<Root>/Delay1'\r\n   *  Sum: '<Root>/Add1'\r\n   */\r\n  rtY_delta_slip_rate[3] = rtDW->MovingAverage4.MovingAverage1_p -\r\n    rtDW->Delay1_DSTATE[3];\r\n\r\n  /* MATLAB Function: '<Root>/CalMaxValveState1' */\r\n  if (rtb_out_state < 0.5) {\r\n    rtb_mc_pressure = 1.0;\r\n  }\r\n\r\n  /* Outport: '<Root>/slip_rate' */\r\n  rtY_slip_rate[0] = rtDW->MovingAverage2.MovingAverage1_p;\r\n  rtY_slip_rate[1] = rtDW->MovingAverage3.MovingAverage1_p;\r\n  rtY_slip_rate[2] = rtDW->MovingAverage4.MovingAverage1_p;\r\n  rtY_slip_rate[3] = rtDW->MovingAverage1_p.MovingAverage1_p;\r\n\r\n  /* Update for Delay: '<Root>/Delay' incorporates:\r\n   *  Switch: '<Root>/Switch'\r\n   */\r\n  rtDW->Delay_DSTATE = (rtb_mc_pressure > 0.0);\r\n\r\n  /* Update for Delay: '<Root>/Delay2' */\r\n  rtDW->Delay2_DSTATE = rtb_abs_is_on;\r\n\r\n  /* Update for Delay: '<Root>/Delay1' incorporates:\r\n   *  SignalConversion generated from: '<Root>/Delay1'\r\n   */\r\n  for (rtb_abs_state_e = 0; rtb_abs_state_e < 3; rtb_abs_state_e++) {\r\n    rtb_out_state = (rtb_abs_state_e + 1) << 2;\r\n    rtb_abs_state = rtb_abs_state_e << 2;\r\n    rtDW->Delay1_DSTATE[rtb_abs_state] = rtDW->Delay1_DSTATE[rtb_out_state];\r\n    rtDW->Delay1_DSTATE[rtb_abs_state + 1] = rtDW->Delay1_DSTATE[rtb_out_state +\r\n      1];\r\n    rtDW->Delay1_DSTATE[rtb_abs_state + 2] = rtDW->Delay1_DSTATE[rtb_out_state +\r\n      2];\r\n    rtDW->Delay1_DSTATE[rtb_abs_state + 3] = rtDW->Delay1_DSTATE[rtb_out_state +\r\n      3];\r\n  }\r\n\r\n  rtDW->Delay1_DSTATE[12] = rtDW->MovingAverage1_p.MovingAverage1_p;\r\n  rtDW->Delay1_DSTATE[13] = rtDW->MovingAverage2.MovingAverage1_p;\r\n  rtDW->Delay1_DSTATE[14] = rtDW->MovingAverage3.MovingAverage1_p;\r\n  rtDW->Delay1_DSTATE[15] = rtDW->MovingAverage4.MovingAverage1_p;\r\n\r\n  /* End of Update for Delay: '<Root>/Delay1' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid ESCHighLevel_initialize(RT_MODEL *const rtM)\r\n{\r\n  DW *rtDW = rtM->dwork;\r\n\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  {\r\n    real_T rtb_wc_p_des_g;\r\n    int32_T rtb_abs_state;\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<Root>/VehSpdEstFunc' */\r\n    VehSpdEstFunction_Init(&rtDW->VehSpdEstFunc);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<Root>/VehSpdEstFunc' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<S1>/SingleWheelStateMachine1' */\r\n    SingleWheelStateMachine_Init(&rtb_wc_p_des_g, &rtb_abs_state);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S1>/SingleWheelStateMachine1' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<S1>/SingleWheelStateMachine2' */\r\n    SingleWheelStateMachine_Init(&rtb_wc_p_des_g, &rtb_abs_state);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S1>/SingleWheelStateMachine2' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<S1>/SingleWheelStateMachine3' */\r\n    SingleWheelStateMachine_Init(&rtb_wc_p_des_g, &rtb_abs_state);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S1>/SingleWheelStateMachine3' */\r\n\r\n    /* SystemInitialize for Atomic SubSystem: '<S1>/SingleWheelStateMachine' */\r\n    SingleWheelStateMachine_Init(&rtb_wc_p_des_g, &rtb_abs_state);\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S1>/SingleWheelStateMachine' */\r\n    MovingAverage1_Init(&rtDW->MovingAverage2);\r\n    MovingAverage1_Init(&rtDW->MovingAverage3);\r\n    MovingAverage1_Init(&rtDW->MovingAverage4);\r\n    MovingAverage1_Init(&rtDW->MovingAverage1_p);\r\n  }\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ESCHighLevel.h","type":"header","group":"model","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ESCHighLevel.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_ESCHighLevel_h_\r\n#define RTW_HEADER_ESCHighLevel_h_\r\n#include <math.h>\r\n#ifndef ESCHighLevel_COMMON_INCLUDES_\r\n#define ESCHighLevel_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* ESCHighLevel_COMMON_INCLUDES_ */\r\n\r\n#include \"ESCHighLevel_types.h\"\r\n\r\n/* Child system includes */\r\n#include \"SlipRateCalFunc.h\"\r\n#include \"VehSpdEstFunction.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetInf.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals and states (default storage) for system '<S1>/SingleWheelStateMachine' */\r\ntypedef struct {\r\n  real_T Delay_DSTATE[4];              /* '<S8>/Delay' */\r\n  int32_T Delay1_DSTATE;               /* '<S8>/Delay1' */\r\n  uint8_T is_active_c20_ESCHighLevel;  /* '<S8>/State Machine' */\r\n  uint8_T is_c20_ESCHighLevel;         /* '<S8>/State Machine' */\r\n} DW_SingleWheelStateMachine;\r\n\r\n/* Block signals and states (default storage) for system '<Root>/Moving Average1' */\r\ntypedef struct {\r\n  dsp_simulink_MovingAverage obj;      /* '<Root>/Moving Average1' */\r\n  real_T MovingAverage1_p;             /* '<Root>/Moving Average1' */\r\n  boolean_T objisempty;                /* '<Root>/Moving Average1' */\r\n} DW_MovingAverage1;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  DW_VehSpdEstFunction VehSpdEstFunc;  /* '<Root>/VehSpdEstFunc' */\r\n  DW_MovingAverage1 MovingAverage4;    /* '<Root>/Moving Average1' */\r\n  DW_MovingAverage1 MovingAverage3;    /* '<Root>/Moving Average1' */\r\n  DW_MovingAverage1 MovingAverage2;    /* '<Root>/Moving Average1' */\r\n  DW_MovingAverage1 MovingAverage1_p;  /* '<Root>/Moving Average1' */\r\n  DW_SingleWheelStateMachine SingleWheelStateMachine3;/* '<S1>/SingleWheelStateMachine3' */\r\n  DW_SingleWheelStateMachine SingleWheelStateMachine2;/* '<S1>/SingleWheelStateMachine2' */\r\n  DW_SingleWheelStateMachine SingleWheelStateMachine1;/* '<S1>/SingleWheelStateMachine1' */\r\n  DW_SingleWheelStateMachine SingleWheelStateMachine_d;/* '<S1>/SingleWheelStateMachine' */\r\n  real_T Delay1_DSTATE[16];            /* '<Root>/Delay1' */\r\n  real_T counter;                      /* '<Root>/MATLAB Function' */\r\n  boolean_T Delay_DSTATE;              /* '<Root>/Delay' */\r\n  boolean_T Delay2_DSTATE;             /* '<Root>/Delay2' */\r\n} DW;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n  DW *dwork;\r\n};\r\n\r\n/* Model entry point functions */\r\nextern void ESCHighLevel_initialize(RT_MODEL *const rtM);\r\nextern void ESCHighLevel_step(RT_MODEL *const rtM, real_T rtU_whlspd[4], real_T\r\n  rtU_acc_x, real_T rtU_cur_mc_pressure, real_T rtU_cur_wc_pressure[4], real32_T\r\n  rtU_abs_para[8], int32_T rtU_abs_use_external_para, real_T *rtY_est_veh_spd,\r\n  int32_T rtY_abs_valve_state[4], real_T rtY_slip_rate[4], real_T\r\n  rtY_delta_slip_rate[4]);\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Add' : Unused code path elimination\r\n * Block '<Root>/Gain' : Unused code path elimination\r\n * Block '<S70>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S71>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S72>/Conversion' : Unused code path elimination\r\n * Block '<S72>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S73>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S30>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S31>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S32>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S33>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S35>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S36>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S37>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S38>/Conversion' : Unused code path elimination\r\n * Block '<S38>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S39>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S40>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S41>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S43>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S25>/G' : Unused code path elimination\r\n * Block '<S25>/H' : Unused code path elimination\r\n * Block '<S25>/N' : Unused code path elimination\r\n * Block '<S25>/P0' : Unused code path elimination\r\n * Block '<S25>/Q' : Unused code path elimination\r\n * Block '<S25>/R' : Unused code path elimination\r\n * Block '<S67>/CheckSignalProperties' : Unused code path elimination\r\n * Block '<S68>/CheckSignalProperties' : Unused code path elimination\r\n * Block '<S69>/CheckSignalProperties' : Unused code path elimination\r\n * Block '<S70>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S71>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S73>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S43>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S47>/Reshape' : Reshape block reduction\r\n * Block '<S25>/ReshapeX0' : Reshape block reduction\r\n * Block '<S25>/Reshapeu' : Reshape block reduction\r\n * Block '<S25>/Reshapexhat' : Reshape block reduction\r\n * Block '<S25>/Reshapey' : Reshape block reduction\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'ESCHighLevel'\r\n * '<S1>'   : 'ESCHighLevel/AbsConStateMachine'\r\n * '<S2>'   : 'ESCHighLevel/CalMaxValveState1'\r\n * '<S3>'   : 'ESCHighLevel/MATLAB Function'\r\n * '<S4>'   : 'ESCHighLevel/SlipRateCalFunc'\r\n * '<S5>'   : 'ESCHighLevel/SteeringWheelToFrontWheel'\r\n * '<S6>'   : 'ESCHighLevel/VehSpdEstFunc'\r\n * '<S7>'   : 'ESCHighLevel/WhlSpdLinCalFunc'\r\n * '<S8>'   : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine'\r\n * '<S9>'   : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine1'\r\n * '<S10>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine2'\r\n * '<S11>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine3'\r\n * '<S12>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine/CalLockCriterion'\r\n * '<S13>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine/Compare To Constant'\r\n * '<S14>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine/State Machine'\r\n * '<S15>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine1/CalLockCriterion'\r\n * '<S16>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine1/Compare To Constant'\r\n * '<S17>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine1/State Machine'\r\n * '<S18>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine2/CalLockCriterion'\r\n * '<S19>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine2/Compare To Constant'\r\n * '<S20>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine2/State Machine'\r\n * '<S21>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine3/CalLockCriterion'\r\n * '<S22>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine3/Compare To Constant'\r\n * '<S23>'  : 'ESCHighLevel/AbsConStateMachine/SingleWheelStateMachine3/State Machine'\r\n * '<S24>'  : 'ESCHighLevel/VehSpdEstFunc/BestWhlSpdEst'\r\n * '<S25>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter'\r\n * '<S26>'  : 'ESCHighLevel/VehSpdEstFunc/spdRefCalFunc'\r\n * '<S27>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL'\r\n * '<S28>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculateYhat'\r\n * '<S29>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CovarianceOutputConfigurator'\r\n * '<S30>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionA'\r\n * '<S31>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionB'\r\n * '<S32>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionC'\r\n * '<S33>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionD'\r\n * '<S34>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionEnable'\r\n * '<S35>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionG'\r\n * '<S36>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionH'\r\n * '<S37>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionN'\r\n * '<S38>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionP'\r\n * '<S39>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionP0'\r\n * '<S40>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionQ'\r\n * '<S41>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionR'\r\n * '<S42>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionReset'\r\n * '<S43>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionX'\r\n * '<S44>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionX0'\r\n * '<S45>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/DataTypeConversionu'\r\n * '<S46>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/MemoryP'\r\n * '<S47>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/Observer'\r\n * '<S48>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/ReducedQRN'\r\n * '<S49>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/Reset'\r\n * '<S50>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/Reshapeyhat'\r\n * '<S51>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/ScalarExpansionP0'\r\n * '<S52>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/ScalarExpansionQ'\r\n * '<S53>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/ScalarExpansionR'\r\n * '<S54>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/UseCurrentEstimator'\r\n * '<S55>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkA'\r\n * '<S56>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkB'\r\n * '<S57>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkC'\r\n * '<S58>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkD'\r\n * '<S59>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkEnable'\r\n * '<S60>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkG'\r\n * '<S61>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkH'\r\n * '<S62>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkN'\r\n * '<S63>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkP0'\r\n * '<S64>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkQ'\r\n * '<S65>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkR'\r\n * '<S66>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkReset'\r\n * '<S67>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checkX0'\r\n * '<S68>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checku'\r\n * '<S69>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/checky'\r\n * '<S70>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL/DataTypeConversionL'\r\n * '<S71>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL/DataTypeConversionM'\r\n * '<S72>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL/DataTypeConversionP'\r\n * '<S73>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL/DataTypeConversionZ'\r\n * '<S74>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculatePL/Ground'\r\n * '<S75>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CalculateYhat/Ground'\r\n * '<S76>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CovarianceOutputConfigurator/decideOutput'\r\n * '<S77>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/CovarianceOutputConfigurator/decideOutput/SqrtUsedFcn'\r\n * '<S78>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/Observer/MeasurementUpdate'\r\n * '<S79>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/ReducedQRN/Ground'\r\n * '<S80>'  : 'ESCHighLevel/VehSpdEstFunc/Kalman Filter/UseCurrentEstimator/Enabled Subsystem'\r\n * '<S81>'  : 'ESCHighLevel/WhlSpdLinCalFunc/Compare To Constant'\r\n * '<S82>'  : 'ESCHighLevel/WhlSpdLinCalFunc/WheelCenterSpdCalFunc'\r\n */\r\n#endif                                 /* RTW_HEADER_ESCHighLevel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ESCHighLevel_private.h","type":"header","group":"model","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ESCHighLevel_private.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_ESCHighLevel_private_h_\r\n#define RTW_HEADER_ESCHighLevel_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"ESCHighLevel.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\nextern void SingleWheelStateMachine_Init(real_T *rty_wc_p_des, int32_T\r\n  *rty_abs_state);\r\nextern void SingleWheelStateMachine(real_T rtu_set_p, real_T rtu_wc_p_cur,\r\n  real_T rtu_u, real_T rtu_slip_rate, const real32_T rtu_abs_para[5], int32_T\r\n  rtu_external_para, real_T *rty_wc_p_des, int32_T *rty_abs_state,\r\n  DW_SingleWheelStateMachine *localDW);\r\nextern void MovingAverage1_Init(DW_MovingAverage1 *localDW);\r\nextern void MovingAverage1(real_T rtu_0, DW_MovingAverage1 *localDW);\r\n\r\n#endif                                 /* RTW_HEADER_ESCHighLevel_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ESCHighLevel_types.h","type":"header","group":"model","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ESCHighLevel_types.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_ESCHighLevel_types_h_\r\n#define RTW_HEADER_ESCHighLevel_types_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Model Code Variants */\r\n#ifndef struct_tag_VywbwoSs6z0Z3AW6Nq2eCH\r\n#define struct_tag_VywbwoSs6z0Z3AW6Nq2eCH\r\n\r\nstruct tag_VywbwoSs6z0Z3AW6Nq2eCH\r\n{\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T pCumSum;\r\n  real_T pCumSumRev[2];\r\n  real_T pCumRevIndex;\r\n  real_T pModValueRev;\r\n};\r\n\r\n#endif                                 /* struct_tag_VywbwoSs6z0Z3AW6Nq2eCH */\r\n\r\n#ifndef typedef_g_dsp_internal_SlidingWindowAve\r\n#define typedef_g_dsp_internal_SlidingWindowAve\r\n\r\ntypedef struct tag_VywbwoSs6z0Z3AW6Nq2eCH g_dsp_internal_SlidingWindowAve;\r\n\r\n#endif                             /* typedef_g_dsp_internal_SlidingWindowAve */\r\n\r\n#ifndef struct_tag_BlgwLpgj2bjudmbmVKWwDE\r\n#define struct_tag_BlgwLpgj2bjudmbmVKWwDE\r\n\r\nstruct tag_BlgwLpgj2bjudmbmVKWwDE\r\n{\r\n  uint32_T f1[8];\r\n};\r\n\r\n#endif                                 /* struct_tag_BlgwLpgj2bjudmbmVKWwDE */\r\n\r\n#ifndef typedef_cell_wrap\r\n#define typedef_cell_wrap\r\n\r\ntypedef struct tag_BlgwLpgj2bjudmbmVKWwDE cell_wrap;\r\n\r\n#endif                                 /* typedef_cell_wrap */\r\n\r\n#ifndef struct_tag_kXGP0IaDlLdwL3QBDwgd6E\r\n#define struct_tag_kXGP0IaDlLdwL3QBDwgd6E\r\n\r\nstruct tag_kXGP0IaDlLdwL3QBDwgd6E\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  boolean_T TunablePropsChanged;\r\n  cell_wrap inputVarSize;\r\n  g_dsp_internal_SlidingWindowAve *pStatistic;\r\n  int32_T NumChannels;\r\n  g_dsp_internal_SlidingWindowAve _pobj0;\r\n};\r\n\r\n#endif                                 /* struct_tag_kXGP0IaDlLdwL3QBDwgd6E */\r\n\r\n#ifndef typedef_dsp_simulink_MovingAverage\r\n#define typedef_dsp_simulink_MovingAverage\r\n\r\ntypedef struct tag_kXGP0IaDlLdwL3QBDwgd6E dsp_simulink_MovingAverage;\r\n\r\n#endif                                 /* typedef_dsp_simulink_MovingAverage */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n#endif                                 /* RTW_HEADER_ESCHighLevel_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"SlipRateCalFunc.c","type":"source","group":"subsystem","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: SlipRateCalFunc.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"SlipRateCalFunc.h\"\r\n\r\n/* Include model header file for global data */\r\n#include \"ESCHighLevel.h\"\r\n#include \"ESCHighLevel_private.h\"\r\n\r\n/* Output and update for atomic system: '<Root>/SlipRateCalFunc' */\r\nvoid SlipRateCalFunc(const real_T rtu_wheel_speed[4], const real_T\r\n                     rtu_wheel_speed_linear[4], real_T rty_slip_rate[4])\r\n{\r\n  /* Switch: '<S4>/Switch' incorporates:\r\n   *  Constant: '<S4>/Constant'\r\n   *  Product: '<S4>/Divide'\r\n   *  Sum: '<S4>/Subtract'\r\n   */\r\n  if (rtu_wheel_speed_linear[0] > 1.0) {\r\n    rty_slip_rate[0] = 1.0 / rtu_wheel_speed_linear[0] *\r\n      (rtu_wheel_speed_linear[0] - rtu_wheel_speed[0]);\r\n  } else {\r\n    rty_slip_rate[0] = 0.0;\r\n  }\r\n\r\n  if (rtu_wheel_speed_linear[1] > 1.0) {\r\n    rty_slip_rate[1] = 1.0 / rtu_wheel_speed_linear[1] *\r\n      (rtu_wheel_speed_linear[1] - rtu_wheel_speed[1]);\r\n  } else {\r\n    rty_slip_rate[1] = 0.0;\r\n  }\r\n\r\n  if (rtu_wheel_speed_linear[2] > 1.0) {\r\n    rty_slip_rate[2] = 1.0 / rtu_wheel_speed_linear[2] *\r\n      (rtu_wheel_speed_linear[2] - rtu_wheel_speed[2]);\r\n  } else {\r\n    rty_slip_rate[2] = 0.0;\r\n  }\r\n\r\n  if (rtu_wheel_speed_linear[3] > 1.0) {\r\n    rty_slip_rate[3] = 1.0 / rtu_wheel_speed_linear[3] *\r\n      (rtu_wheel_speed_linear[3] - rtu_wheel_speed[3]);\r\n  } else {\r\n    rty_slip_rate[3] = 0.0;\r\n  }\r\n\r\n  /* End of Switch: '<S4>/Switch' */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"SlipRateCalFunc.h","type":"header","group":"subsystem","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: SlipRateCalFunc.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_SlipRateCalFunc_h_\r\n#define RTW_HEADER_SlipRateCalFunc_h_\r\n#ifndef ESCHighLevel_COMMON_INCLUDES_\r\n#define ESCHighLevel_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* ESCHighLevel_COMMON_INCLUDES_ */\r\n\r\n#include \"ESCHighLevel_types.h\"\r\n\r\nextern void SlipRateCalFunc(const real_T rtu_wheel_speed[4], const real_T\r\n  rtu_wheel_speed_linear[4], real_T rty_slip_rate[4]);\r\n\r\n#endif                                 /* RTW_HEADER_SlipRateCalFunc_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"VehSpdEstFunction.c","type":"source","group":"subsystem","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: VehSpdEstFunction.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"VehSpdEstFunction.h\"\r\n\r\n/* Include model header file for global data */\r\n#include \"ESCHighLevel.h\"\r\n#include \"ESCHighLevel_private.h\"\r\n\r\n/* System initialize for atomic system: '<Root>/VehSpdEstFunc' */\r\nvoid VehSpdEstFunction_Init(DW_VehSpdEstFunction *localDW)\r\n{\r\n  /* InitializeConditions for Delay: '<S25>/MemoryX' */\r\n  localDW->icLoad = true;\r\n}\r\n\r\n/* Output and update for atomic system: '<Root>/VehSpdEstFunc' */\r\nreal_T VehSpdEstFunction(real_T rtu_w1, real_T rtu_w2, real_T rtu_w3, real_T\r\n  rtu_w4, boolean_T rtu_brk_flag, real_T rtu_a_x, boolean_T rtu_abs_is_on,\r\n  int32_T rtu_use_external_para, real32_T rtu_modify_factor,\r\n  DW_VehSpdEstFunction *localDW)\r\n{\r\n  real_T rty_est_veh_spd_0;\r\n  real_T x[4];\r\n  real_T rtb_best_whl_spd;\r\n\r\n  /* MATLAB Function: '<S6>/BestWhlSpdEst' */\r\n  if (rtu_brk_flag) {\r\n    int32_T idx;\r\n    x[0] = rtu_w1;\r\n    x[1] = rtu_w2;\r\n    x[2] = rtu_w3;\r\n    x[3] = rtu_w4;\r\n    if (!rtIsNaN(rtu_w1)) {\r\n      idx = 1;\r\n    } else {\r\n      int32_T k;\r\n      boolean_T exitg1;\r\n      idx = 0;\r\n      k = 2;\r\n      exitg1 = false;\r\n      while ((!exitg1) && (k < 5)) {\r\n        if (!rtIsNaN(x[k - 1])) {\r\n          idx = k;\r\n          exitg1 = true;\r\n        } else {\r\n          k++;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (idx == 0) {\r\n      rtb_best_whl_spd = rtu_w1;\r\n    } else {\r\n      rtb_best_whl_spd = x[idx - 1];\r\n      while (idx + 1 <= 4) {\r\n        if (rtb_best_whl_spd < x[idx]) {\r\n          rtb_best_whl_spd = x[idx];\r\n        }\r\n\r\n        idx++;\r\n      }\r\n    }\r\n  } else {\r\n    rtb_best_whl_spd = (rtu_w1 + rtu_w2) / 2.0;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S6>/BestWhlSpdEst' */\r\n\r\n  /* Delay: '<S25>/MemoryX' incorporates:\r\n   *  Constant: '<S6>/Constant'\r\n   */\r\n  if (localDW->icLoad) {\r\n    localDW->MemoryX_DSTATE = 0.0;\r\n  }\r\n\r\n  /* MATLAB Function: '<S6>/spdRefCalFunc' incorporates:\r\n   *  Constant: '<S6>/Constant1'\r\n   *  Delay: '<S6>/Delay1'\r\n   */\r\n  if (!rtu_brk_flag) {\r\n    localDW->modify_flag = 0.0;\r\n  }\r\n\r\n  if ((localDW->modify_flag == 0.0) && rtu_abs_is_on) {\r\n    real_T rtu_use_external_para_0;\r\n    localDW->modify_flag = 1.0;\r\n\r\n    /* Switch: '<S6>/Switch1' incorporates:\r\n     *  Constant: '<S6>/Constant2'\r\n     */\r\n    if (rtu_use_external_para > 0) {\r\n      rtu_use_external_para_0 = rtu_modify_factor;\r\n    } else {\r\n      rtu_use_external_para_0 = 0.03;\r\n    }\r\n\r\n    /* End of Switch: '<S6>/Switch1' */\r\n    rty_est_veh_spd_0 = (rtu_use_external_para_0 + 1.0) * localDW->Delay1_DSTATE\r\n      + rtu_a_x * 0.008;\r\n  } else {\r\n    rty_est_veh_spd_0 = rtu_a_x * 0.008 + localDW->Delay1_DSTATE;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S6>/spdRefCalFunc' */\r\n\r\n  /* Switch: '<S6>/Switch' incorporates:\r\n   *  Constant: '<S27>/KalmanGainM'\r\n   *  Delay: '<S25>/MemoryX'\r\n   *  Product: '<S80>/Product2'\r\n   *  Sum: '<S54>/Add'\r\n   *  Sum: '<S80>/Add1'\r\n   */\r\n  if (!rtu_abs_is_on) {\r\n    /* Outputs for Enabled SubSystem: '<S54>/Enabled Subsystem' incorporates:\r\n     *  EnablePort: '<S80>/Enable'\r\n     */\r\n    rty_est_veh_spd_0 = (rtb_best_whl_spd - localDW->MemoryX_DSTATE) *\r\n      0.7320508075688773 + localDW->MemoryX_DSTATE;\r\n\r\n    /* End of Outputs for SubSystem: '<S54>/Enabled Subsystem' */\r\n  }\r\n\r\n  /* End of Switch: '<S6>/Switch' */\r\n\r\n  /* Update for Delay: '<S25>/MemoryX' incorporates:\r\n   *  Constant: '<S25>/B'\r\n   *  Constant: '<S25>/D'\r\n   *  Constant: '<S27>/KalmanGainL'\r\n   *  Product: '<S47>/B[k]*u[k]'\r\n   *  Product: '<S78>/D[k]*u[k]'\r\n   *  Product: '<S78>/Product3'\r\n   *  Sum: '<S47>/Add'\r\n   *  Sum: '<S78>/Add1'\r\n   *  Sum: '<S78>/Sum'\r\n   */\r\n  localDW->icLoad = false;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S47>/MeasurementUpdate' incorporates:\r\n   *  EnablePort: '<S78>/Enable'\r\n   */\r\n  localDW->MemoryX_DSTATE = (rtb_best_whl_spd - (0.0 * rtu_a_x +\r\n    localDW->MemoryX_DSTATE)) * 0.732050807568877 + (0.008 * rtu_a_x +\r\n    localDW->MemoryX_DSTATE);\r\n\r\n  /* End of Outputs for SubSystem: '<S47>/MeasurementUpdate' */\r\n\r\n  /* Update for Delay: '<S6>/Delay1' */\r\n  localDW->Delay1_DSTATE = rty_est_veh_spd_0;\r\n  return rty_est_veh_spd_0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"VehSpdEstFunction.h","type":"header","group":"subsystem","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: VehSpdEstFunction.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_VehSpdEstFunction_h_\r\n#define RTW_HEADER_VehSpdEstFunction_h_\r\n#ifndef ESCHighLevel_COMMON_INCLUDES_\r\n#define ESCHighLevel_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* ESCHighLevel_COMMON_INCLUDES_ */\r\n\r\n#include \"ESCHighLevel_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Block signals and states (default storage) for system '<Root>/VehSpdEstFunc' */\r\ntypedef struct {\r\n  real_T MemoryX_DSTATE;               /* '<S25>/MemoryX' */\r\n  real_T Delay1_DSTATE;                /* '<S6>/Delay1' */\r\n  real_T modify_flag;                  /* '<S6>/spdRefCalFunc' */\r\n  boolean_T icLoad;                    /* '<S25>/MemoryX' */\r\n} DW_VehSpdEstFunction;\r\n\r\nextern void VehSpdEstFunction_Init(DW_VehSpdEstFunction *localDW);\r\nextern real_T VehSpdEstFunction(real_T rtu_w1, real_T rtu_w2, real_T rtu_w3,\r\n  real_T rtu_w4, boolean_T rtu_brk_flag, real_T rtu_a_x, boolean_T rtu_abs_is_on,\r\n  int32_T rtu_use_external_para, real32_T rtu_modify_factor,\r\n  DW_VehSpdEstFunction *localDW);\r\n\r\n#endif                                 /* RTW_HEADER_VehSpdEstFunction_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Huiqian\\THU\\Projects\\ESC\\数据\\ESCHighLevel\\ESCHighLevel_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'ESCHighLevel'.\r\n *\r\n * Model version                  : 1.37\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Mon May 30 18:56:02 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: NXP->Cortex-M4\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: NXP->Cortex-M4\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};